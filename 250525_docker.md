
# Dockerはじめてガイド：Mac/Windows/Ubuntu対応 初心者向けセットアップ＆基本操作まとめ

# 🚀 はじめに

この記事では、これからDockerを使って開発を始めたい方向けに、

- OS別インストール方法（Mac，Windows，Ubuntu対応）
- Dockerfileやdocker-composeの記述方法
- 画像・コンテナ操作の基本と応用
- コンテナ開発環境の整備（VS Code連携）
- Docker Hubでの公開・共有方法

などを**一気通貫で解説**します。  
最初はこれを覚えておけば問題ないです。

# 🧭 目次

## 初級編
1. 🛠 Dockerのインストール & 初期設定
2. 🧾 Dockerfile / .dockerignore / docker-compose.yml の書き方
3. 📦 イメージの基本操作
4. 🚢 コンテナの基本操作
5. 🧑‍💻 VS Codeでのコンテナ開発

## 応用編
6. 🔧 Git/GitHub連携と環境構築
7. 🏷 イメージのタグ操作と保存・読み込み
8. ☁️ Docker Hubへのアップロードと管理

# 🛠 1. Dockerのインストール & 初期設定

## 🍎 Mac
- [Docker Desktop for Mac](https://www.docker.com/products/docker-desktop/) をダウンロード＆インストール

## 🪟 Windows
- WSL2の有効化 & Docker Desktopインストール  
  公式ガイド: [Windowsでのセットアップ](https://docs.docker.com/desktop/install/windows-install/)

## 🐧 Ubuntu
```bash
sudo apt update
sudo apt install docker.io -y
sudo systemctl enable --now docker
```

ユーザを`docker`グループに追加（sudo不要化）:
```bash
sudo usermod -aG docker $USER
newgrp docker
```

Docker起動確認：
```bash
docker --version
docker run hello-world
```

# 🧾 2. Dockerfile / .dockerignore / docker-compose.yml の書き方

## 🔨 Dockerfileの基本構成
以下にDockerfileでよく使うコマンド一覧を示し，最後に実際のDockerfile例を示す．  
最初は軽く読み流す程度で良い．
### FROM：ベースイメージの指定（必須）
DockerFileの一番最初に1行だけ記述  
例：
```Dockerfile
FROM ubuntu:22.04
FROM python:3.11-slim
FROM node:18-alpine
```

- [Docker Hub](https://hub.docker.com/) で公式やverifiedイメージを検索
- 開発用途に応じて適切なベースを選ぶ

#### 📌 代表的なベースイメージの使い分け例：
- `ubuntu`：汎用的なLinux環境。何をするか未定でとりあえず環境を整えたいときに便利。
- `python`：Pythonの実行環境を簡単に整えたいとき。`-slim`は不要なツールを省いた軽量バージョン。
    - 他にも`python:3.11`, `python:3.11-alpine`, `python:3.11-bullseye`などがある。
- `node`：Node.jsベースでWeb開発を行いたい場合に。`-alpine`は非常に軽量で本番環境向けにもよく使われる。



### RUN：ビルド時のコマンド実行
`RUN` は Docker イメージのビルド中に一度だけ実行されるシェルコマンドです。パッケージのインストールやファイル操作など、環境構築に必要な処理を記述します。

#### ✅ よくある使い方（基本）

```Dockerfile
RUN apt update
RUN apt update && apt install -y curl git
RUN pip install -r requirements.txt
```

- `&&` でまとめると、**中間レイヤーの数が減って**ビルドが速くなり、キャッシュも効きやすくなります。

#### ✅ 複数行に分けたいとき（可読性のため）

```Dockerfile
RUN apt update && \
    apt install -y \
    curl \
    git \
    unzip
```

- `\`（バックスラッシュ）と改行を使って、**見やすく整形**できます。
- `--no-cache-dir` は一時ファイルを残さないオプション（コンテナサイズ削減に有効）

### COPY：ローカルファイルのコピー
```Dockerfile
COPY . /app
COPY requirements.txt /app/
```

### ADD：COPY＋α（tar展開やURL対応）
```Dockerfile
ADD archive.tar.gz /app/
ADD https://example.com/data.csv /data.csv
```

### WORKDIR：作業ディレクトリ指定
シェルでの`cd`コマンドに相当，カレントディレクトリを変更できる．
```Dockerfile
WORKDIR /app
```

### ENV：環境変数の設定
```Dockerfile
ENV TZ=Asia/Tokyo
ENV NODE_ENV=production
```

### EXPOSE：使用予定ポートの宣言
```Dockerfile
EXPOSE 3000
```

### VOLUME：永続化ポイント
コンテナ内の指定したパスを，ローカルのどこかにマウントして，コンテナが削除された後も残るようにする．後述する`docker-compose.yml`にも同様に`volumes:`の設定が可能で、そちらにマウント先を明示的に書いた場合は`compose`側が優先される．そのため、`Dockerfile`で `VOLUME`を書かなくても問題ないケースがほとんど．  
例：
```Dockerfile
VOLUME /var/lib/mysql
```

### CMD：コンテナ起動時コマンド
コンテナが起動されたときにデフォルトで実行されるコマンドを指定します。  
通常は`Dockerfile`の最後に1行だけ記述します（複数指定しても最後のものだけが有効です）。
```Dockerfile
CMD ["node", "app.js"]
CMD ["python3", "main.py"]
```

### ENTRYPOINT：`CMD`より強制力ある起動処理
コンテナ起動時に常に実行されるコマンドを固定する命令です。  
`CMD`と同様、`Dockerfile`に複数書いても最後の1つだけが有効になります。
```Dockerfile
ENTRYPOINT ["python3", "main.py"]
```

#### 🆚 `CMD`との違い

`CMD` は「**何も指定がなければこれを実行してね**」という**デフォルトの起動コマンド**を定義します。  
一方で `ENTRYPOINT` は「**必ずこれを実行する（上書き不可）コマンド**」を定義します。


#### 🧪 実行例

`CMD`の場合：
```Dockerfile
CMD ["echo", "hello"]
```

```bash
docker run myimage           # → echo hello
docker run myimage echo bye       # → echo bye（上書きされる）
```

---

`ENTRYPOINT`の場合：
```Dockerfile
ENTRYPOINT ["python3", "app.py"]
```

```bash
docker run myimage           # → python3 app.py
docker run myimage bye       # → echpython3o app.py bye（後ろに追加される）
```

---

`CMD`と`ENTRYPOINT`の組み合わせ（最も実用的）：
```Dockerfile
ENTRYPOINT ["echo"]
CMD ["hello"]
```

```bash
docker run myimage           # → echo hello
docker run myimage bye       # → echo bye
```

#### ✅ 結論

- `CMD`：**柔軟性重視**。ユーザーが自由に上書きしたいとき向き。
- `ENTRYPOINT`：**固定実行重視**。CLIなどで処理を必ず実行したいときに最適。
- **最もよく使われるのは `ENTRYPOINT` + `CMD` の組み合わせ**。


### ⏰ タイムゾーン設定例（Ubuntu）
```Dockerfile
ENV TZ=Asia/Tokyo
RUN apt update && \
    DEBIAN_FRONTEND=noninteractive apt install -y tzdata && \
    ln -sf /usr/share/zoneinfo/$TZ /etc/localtime && \
    dpkg-reconfigure -f noninteractive tzdata
```

### 💡 実用Dockerfile例：Flask API
```Dockerfile
# Python 3.11 の軽量バージョン（不要なパッケージが削られた）をベースに使用
FROM python:3.11-slim

# タイムゾーンを日本時間（Asia/Tokyo）に設定
ENV TZ=Asia/Tokyo

# 作業ディレクトリを /app に設定（以降のCOPYやRUNの基準パスになる）
WORKDIR /app

# 依存関係ファイルだけを先にコピー（Dockerのレイヤーキャッシュを活用するため）
COPY requirements.txt .

# Pythonパッケージを一括インストール（キャッシュを残さずコンテナを軽く保つ）
RUN pip install --no-cache-dir -r requirements.txt

# プロジェクトの全ファイルをコンテナにコピー（例: app.py, templates/, static/ など）
COPY . .

# Flaskのデフォルトポート（5000番）を外部公開（任意）
EXPOSE 5000

# エントリポイントを flask に固定（CMDはその引数として渡る）
ENTRYPOINT ["flask"]

# デフォルト引数を設定（上書き可）
CMD ["run", "--host=0.0.0.0", "--port=5000"]
```

## 🙈 .dockerignore：ビルド時に無視するファイルを指定する設定ファイル

`.dockerignore` は、`Dockerfile`と同じディレクトリに置き、コンテナのビルド時に **イメージに含めたくないファイル・ディレクトリを除外**するための設定ファイルです。  
これは `.gitignore` に似ていますが、Dockerにおいては **イメージのサイズ・セキュリティ・ビルド速度**に大きく影響します。

### ✅ なぜ重要？

- **不要なファイル**（ログ・一時ファイル）がイメージに含まれない
- **秘密情報**（`.env`, `credentials.json` など）をうっかり含めないようにできる
- **ビルドが高速化**する（送信対象のビルドコンテキストが軽くなる）



### 📝 基本的な書き方の例

```dockerignore
# Pythonキャッシュや中間ファイル
__pycache__/
*.py[cod]

# 環境ファイル（秘密情報）
.env
credentials.json

# ビルド・仮想環境
dist/
build/
venv/

# Git関連
.git
.gitignore

# エディタやOSの一時ファイル
.vscode/
.idea/
.DS_Store
*.swp
```

### ⚠️ `.env` や `.git` を除外する理由

- `.env` や `credentials.json` は、APIキーやトークンが入っていることが多く、**Dockerイメージに焼き付くと非常に危険です**。
    - イメージファイルを他人に配布しない，かつローカルで自分しか使わないのであればコンテナに入れても問題ない．
    - 後述する`docker-compose.yml`を使えば環境変数も使えるため，原則コピーしないようにしてください．
- `.git` は大量の不要ファイルを含み、**イメージ肥大化とビルド遅延の原因**になります。
    - それでも必要であれば、`Dockerfile`に`git init`等の`.git`情報を再構成する処理を入れる設計にすることで、安全に最小限のGit情報だけを扱うことが可能です。

### ✅ まとめ

| 対象ファイル     | `.dockerignore` に含めるべき？ | 理由                                               |
|------------------|-------------------------------|----------------------------------------------------|
| `.env`           | ✅ 原則含める                   | 認証情報が含まれるため危険。実行時に渡すべき。     |
| `.git/`          | ✅ 原則含める                   | サイズ肥大・ビルド遅延防止。       |
| `.vscode/`, `.DS_Store` | ✅ 含める               | エディタ・OS依存の不要ファイル                    |

`.dockerignore` はセキュリティ・効率・安定性を保つために極めて重要な設計要素です。  
「入れる・入れない」は**運用設計に基づいて明確に判断しましょう**。

## 🧩 docker-compose.yml の構成と役割

`docker-compose.yml`は、複数の Docker コンテナ（サービス）をまとめて構築・起動・管理するための設定ファイルです。通常の`docker run`では1つずつ手動で起動しますが、Compose を使えばネットワークやボリューム、依存関係まで含めて一括管理できます。

### 🔍 主な構成要素

| キー           | 説明                                                                 |
|----------------|----------------------------------------------------------------------|
| `version`      | Composeファイルのバージョン（一般的に `3.8` 以上を推奨）            |
| `services`     | 起動するコンテナ群の定義                                             |
| `image`        | 使用するDockerイメージを指定                   |
| `container_name` | ビルド後のコンテナ名を指定
| `build`        | ローカルのDockerfileのパスを指定                       |
| `ports`        | ホストとコンテナのポートマッピング                                  |
| `volumes`      | コンテナの永続化またはコード同期設定                                 |
| `environment`  | 環境変数の設定（`.env` ファイルとも連携可能）                        |
| `networks`     | 複数コンテナ間でネットワークを管理                  |
| `depends_on`   | 起動順の制御                                                         |
| `tty`          | teletypewriter略，コンソールを使えるようにする       |

#### 🧩 `version`
```yaml
version: '3.8'
```
- Composeファイルの仕様バージョン。
- `3.8` 以上が推奨。最新の機能が使用可能。

#### 🧩 `services`
```yaml
services:
  frontend:
    ...
```
- 起動するアプリケーションごとのコンテナ定義ブロック。
- それぞれに `build`, `ports`, `volumes` などを記述。

#### 🧩 `image`
```yaml
image: client-image
```
- 使用するDockerイメージを指定。次の2種類の使い方がある
  - `docker pull` したイメージファイル名の指定
  - ローカルのDockerfileをビルドしたときのイメージファイル名の指定

#### 🧩 `container_name`
```yaml
container_name: client
```
- ビルド時のコンテナ名を明示的に指定。
- CLI操作時やログの識別に便利。

#### 🧩 `build`
```yaml
build:
  context: ./client
  dockerfile: Dockerfile
```
- Dockerfileのパスとビルド対象ディレクトリを指定。

#### 🧩 `ports`
```yaml
ports:
  - "5001:5173"
```
- ホスト⇔コンテナ間のポート転送。
- `"ホストポート:コンテナポート"` の形式。

#### 🧩 `volumes`
```yaml
volumes:
  - ./client:/app
  - /app/node_modules
```
- ホストとコンテナ間のファイル同期または永続化。
- `node_modules` などはホストに影響させないための無視ボリュームとしても使える。

#### 🧩 `environment`
```yaml
environment:
  - FLASK_ENV=development
  - API_KEY=${API_KEY}
```
- コンテナ内に渡す環境変数。
- `.env` ファイルから自動展開可能。

#### 🧩 `networks`
```yaml
networks:
  - web-app-network
```
- 複数のコンテナを同一ネットワークに配置して通信を可能にする。
- 名前解決（例：`http://backend:3000`）ができるようになる。

#### 🧩 `depends_on`
```yaml
depends_on:
  - backend
```
- 起動順制御（例：backendを先に起動）。
- コンテナの“準備完了”は保証されない点に注意

#### 🧩 `tty`
```yaml
tty: true
```
- 仮想端末（TTY）を割り当てる。
- ログ表示の整形や対話的CLI操作で有効。

### ✅ 基本構成の例

```yaml
# Composeファイルのバージョン指定（3.8は安定して使いやすい）
version: '3.8'

services:
  # フロントエンドサービスの定義
  frontend:
    image: client-image  # ビルド後のイメージ名として使用
    container_name: client  # 実行中のコンテナに付ける名前
    build:
      context: ./client       # Dockerfile のあるディレクトリを指定
      dockerfile: Dockerfile  # 使用するDockerfile名（省略可能だが明示している）
    ports:
      - "5001:5173"           # ホスト5001 → コンテナ5173
    volumes:
      - ./client:/app         # クライアントソースをコンテナにマウント（ホットリロード対応）
      - /app/node_modules     # node_modules をホスト側と分離（競合防止）
    networks:
      - web-app-network       # backendと同じネットワークで通信可能にする
    depends_on:
      - backend               # backendを先に起動してからfrontendを起動
    tty: true                 # 仮想端末を割り当て（ログ整形やbashでの操作用）

  # バックエンドサービスの定義
  backend:
    image: server-image
    container_name: server
    build:
      context: ./server
      dockerfile: Dockerfile
    ports:
      - "3001:3000"
    volumes:
      - ./server:/server
    networks:
      - web-app-network
    tty: true

# コンテナ間通信のための共通ネットワークを定義
networks:
  web-app-network:
    driver: bridge            # Docker標準のブリッジネットワークドライバ
```

# 📦 3. イメージの基本操作

- イメージプル（Docker Hubなどから取得）：
  ```bash
  docker pull ubuntu:22.04
  ```

- イメージビルド：
  ```bash
  docker build -t myimage:latest .
  ```

- イメージ一覧表示：
  ```bash
  docker images
  ```

- イメージ削除：
  ```bash
  docker rmi myimage
  ```

# 🚢 4. コンテナの基本操作

- コンテナ生成＆起動：
  ```bash
  docker run -it --name mycontainer ubuntu
  ```

- GPUを使う場合（NVIDIA環境）：
  ```bash
  docker run --gpus all --name gpu_container nvidia/cuda:12.2.0-base
  ```

- バックグラウンド起動（-d）とネットワーク指定：
  ```bash
  docker run -d --network host --name net_container nginx
  ```

- コンテナ一覧：  
    - "-a"オプションをつけると全コンテナを表示可能  
    - "ps"と"container ls"はどっちでもいい
  ```bash
  docker ps
  docker ps -a
  docker container ls
  docker container ls -a
  ```

- 起動 / 停止 / 再起動 / 削除：
  ```bash
  docker start mycontainer
  docker stop mycontainer
  docker restart mycontainer
  docker rm mycontainer
  ```

- 接続（中に入る）：
  ```bash
  docker exec -it mycontainer bash
  ```

- 名前変更：
  ```bash
  docker rename oldname newname
  ```

- ファイル転送：
  ```bash
  docker cp local.txt mycontainer:/app/
  docker cp mycontainer:/app/output.txt .
  ```

# 🧑‍💻 5. VS Codeでのコンテナ開発

- 拡張機能「Remote - Containers」インストール
- `.devcontainer` フォルダ作成
- 起動: `F1 → Remote-Containers: Open Folder in Container`

# 🔧 6. Git/GitHub連携と開発環境構築

- Git/ghのインストール：
  ```bash
  sudo apt install git gh
  gh auth login
  ```

# 🏷 7. イメージのタグ操作と保存・読み込み

- タグ設定：
  ```bash
  docker tag myimage:latest myimage:v1.0
  ```

- コンテナ → イメージ化：
  ```bash
  docker commit mycontainer myimage:custom
  ```

- イメージ → tarファイル保存：
  ```bash
  docker save -o myimage.tar myimage
  ```

- tarファイル → イメージ読込：
  ```bash
  docker load -i myimage.tar
  ```

# ☁️ 8. Docker Hub連携

- ログイン：
  ```bash
  docker login
  ```

- アップロード：
  ```bash
  docker tag myimage username/myimage
  docker push username/myimage
  ```

- ログアウト：
  ```bash
  docker logout
  ```

# ✅ まとめ

Dockerを用いた開発は、環境構築を自動化し、再現性のある開発を可能にします。  
まずは初級編の操作に慣れ、必要に応じて応用編の内容に進んでいきましょう。
